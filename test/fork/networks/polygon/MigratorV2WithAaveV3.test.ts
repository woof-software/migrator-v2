import {
    ethers,
    expect,
    parseEther,
    Zero,
    MaxUint256,
    anyValue,
    impersonateAccount,
    stopImpersonatingAccount,
    setBalance,
    parseUnits,
    loadFixture,
    logger,
    AddressZero
} from "../../../helpers"; // Adjust the path as needed

import {
    MigratorV2,
    AaveV3UsdsAdapter,
    IComet__factory,
    IWrappedTokenGatewayV3__factory,
    ERC20__factory,
    ERC20,
    IAToken__factory,
    IAToken,
    IDebtToken__factory,
    IDebtToken
} from "../../../../typechain-types";

import { AavePool__factory, WrappedTokenGatewayV3__factory } from "../../types/contracts";

/**
 *  **Fork Tests: How to Run**
 *
 *  **Fill in the `.env` file** according to the provided example, specifying correct RPC URLs and fork block numbers.
 *
 *  **Running Fork Tests**
 *    - The main command to execute a fork test:
 *      ```sh
 *      npm run test-f-aave --fork-network=polygon
 *      ```
 *
 *  **Enabling Debug Logs**
 *    - To display additional debug logs (collateral balances and borrow positions before and after migration),
 *      add the `--debug-log=true` flag:
 *      ```sh
 *      npm run test-f-aave --debug-log=true --fork-network=polygon
 *      ```
 *
 *  **How Fork Tests Work**
 *    - The tests run on a **fixed block number** defined in the `.env` file.
 *    - **To execute tests on the latest network block**, remove the `FORKING_POLYGON_BLOCK` variable from `.env`:
 *      ```env
 *      # Remove or comment out this line:
 *      # FORKING_POLYGON_BLOCK=
 *      ```
 */

// Convert fee to 3-byte hex
const FEE_3000 = ethers.utils.hexZeroPad(ethers.utils.hexlify(3000), 3); // 0.3% 0x0BB8
const FEE_500 = ethers.utils.hexZeroPad(ethers.utils.hexlify(500), 3); // 0.05% 0x01F4
const FEE_100 = ethers.utils.hexZeroPad(ethers.utils.hexlify(100), 3); // 0.01% 0x0064

const POSITION_ABI = [
    "tuple(address debtToken, uint256 amount, tuple(bytes path, uint256 deadline, uint256 amountInMaximum) swapParams)[]",
    "tuple(address aToken, uint256 amount, tuple(bytes path, uint256 deadline, uint256 amountOutMinimum) swapParams)[]"
];

const SLIPPAGE_BUFFER_PERCENT = 115; // 15% slippage buffer

describe("MigratorV2 and AaveV3UsdsAdapter contracts", function () {
    async function setupEnv() {
        const [owner, user] = await ethers.getSigners();
        console.log("Network:", process.env.npm_config_fork_network || "not set");
        console.log("Block number:", await ethers.provider.getBlockNumber());

        const tokenAddresses: Record<string, string> = {
            WBTC: "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6",
            DAI: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",
            USDCe: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
            USDT: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
            WMATIC: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
            LINK: "0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39"
        };

        const treasuryAddresses: Record<string, string> = {
            WBTC: "0x0AFF6665bB45bF349489B20E225A6c5D78E2280F",
            DAI: "0xaB3aEF192748E9Cf1A3Faf0e261a54a2D5a99E2A",
            USDCe: "0x9c2bd617b77961ee2c5e3038dFb0c822cb75d82a",
            USDT: "0x1AB4973a48dc892Cd9971ECE8e01DcC7688f8F23",
            WMATIC: "0x2194F90d32dF768c9Bfdbd3215d677eaA6FC3c4F",
            LINK: "0x509dB14Ae32a43B98C6427bea50d0915c38C0196"
        };

        const aaveContractAddresses = {
            aToken: {
                WBTC: "0x078f358208685046a11C85e8ad32895DED33A249",
                DAI: "0x82E64f49Ed5EC1bC6e43DAD4FC8Af9bb3A2312EE",
                USDCe: "0x625E7708f30cA75bfd92586e17077590C60eb4cD",
                USDT: "0x6ab707Aca953eDAeFBc4fD23bA73294241490620",
                WMATIC: "0x6d80113e533a2C0fe82EaBD35f1875DcEA89Ea97",
                LINK: "0x191c10Aa4AF7C30e871E70C95dB0E4eb77237530"
            },
            variableDebtToken: {
                WBTC: "0x92b42c66840C7AD907b4BF74879FF3eF7c529473",
                DAI: "0x8619d80FB0141ba7F184CbF22fd724116D9f7ffC",
                USDCe: "0xFCCf3cAbbe80101232d343252614b6A3eE81C989",
                USDT: "0xfb00AC187a8Eb5AFAE4eACE434F493Eb62672df7",
                WMATIC: "0x4a1c3aD6Ed28a636ee1751C69071f6be75DEb8B8",
                LINK: "0x953A573793604aF8d41F306FEb8274190dB4aE0e"
            },
            pool: "0x794a61358D6845594F94dc1DB02A252b5b4814aD",
            protocolDataProvider: "0x7F23D86Ee20D869112572136221e173428DD740B",
            wrappedTokenGateway: "0xF5f61a1ab3488fCB6d86451846bcFa9cdc108eB0"
        };

        const uniswapContractAddresses = {
            router: "0xE592427A0AEce92De3Edee1F18E0157C05861564",
            pools: {
                USDCe_USDC: "0xD36ec33c8bed5a9F7B6630855f1533455b98a418"
            }
        };

        const compoundContractAddresses = {
            markets: {
                cUSDCev3: "0xF25212E676D1F7F89Cd72fFEe66158f541246445"
            }
        };

        const tokenContracts: Record<string, ERC20> = Object.fromEntries(
            Object.entries(tokenAddresses).map(([symbol, address]) => [symbol, ERC20__factory.connect(address, user)])
        );

        const tokenDecimals: Record<string, number> = Object.fromEntries(
            await Promise.all(
                Object.entries(tokenContracts).map(async ([symbol, contract]) => {
                    const decimals = await contract.decimals();
                    return [symbol, decimals];
                })
            )
        );

        const aTokenContracts: Record<string, IAToken> = Object.fromEntries(
            Object.entries(aaveContractAddresses.aToken).map(([symbol, address]) => [
                symbol,
                IAToken__factory.connect(address, user)
            ])
        );

        const debtTokenContracts: Record<string, IDebtToken> = Object.fromEntries(
            Object.entries(aaveContractAddresses.variableDebtToken).map(([symbol, address]) => [
                symbol,
                IDebtToken__factory.connect(address, user)
            ])
        );

        const AaveV3UsdsAdapterFactory = await ethers.getContractFactory("AaveV3UsdsAdapter", owner);
        const AaveV3UsdsAdapter = (await AaveV3UsdsAdapterFactory.connect(owner).deploy({
            uniswapRouter: uniswapContractAddresses.router,
            daiUsdsConverter: AddressZero,
            dai: AddressZero,
            usds: AddressZero,
            aaveLendingPool: aaveContractAddresses.pool,
            aaveDataProvider: aaveContractAddresses.protocolDataProvider,
            isFullMigration: true,
            useSwapRouter02: false
        })) as AaveV3UsdsAdapter;
        await AaveV3UsdsAdapter.deployed();

        const adapters = [AaveV3UsdsAdapter.address];
        const comets = [compoundContractAddresses.markets.cUSDCev3]; // Compound USDCe (cUSDCev3) market

        // Set up flashData for migrator
        const flashData = [
            {
                liquidityPool: uniswapContractAddresses.pools.USDCe_USDC, // Uniswap V3 pool USDCe / WMATIC
                baseToken: tokenAddresses.USDCe, // USDCe
                isToken0: true
            }
        ];

        const MigratorV2Factory = await ethers.getContractFactory("MigratorV2");
        const migratorV2 = (await MigratorV2Factory.connect(owner).deploy(
            owner.address,
            adapters,
            comets,
            flashData,
            AddressZero,
            AddressZero
        )) as MigratorV2;
        await migratorV2.deployed();

        expect(migratorV2.address).to.be.properAddress;

        // Connecting to all necessary contracts for testing
        const aaveV3Pool = AavePool__factory.connect(aaveContractAddresses.pool, user);

        const wrappedTokenGateway = WrappedTokenGatewayV3__factory.connect(
            aaveContractAddresses.wrappedTokenGateway,
            user
        );

        return {
            owner,
            user,
            treasuryAddresses,
            tokenAddresses,
            tokenContracts,
            tokenDecimals,
            aaveContractAddresses,
            aTokenContracts,
            debtTokenContracts,
            uniswapContractAddresses,
            compoundContractAddresses,
            AaveV3UsdsAdapter,
            migratorV2,
            aaveV3Pool,
            wrappedTokenGateway
        };
    }

    context("Migrate positions from AaveV3 to Compound III", function () {
        it("Scn.#1: migration of all collaterals | three collateral (incl. Native Token) and three borrow tokens | only swaps (coll. & borrow pos.)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC), // ~ 955 USD
                USDT: parseUnits("300", tokenDecimals.USDT)
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1385 USD
            const supplyAmounts = {
                MATIC: parseEther("430"), // 130 USD
                WBTC: fundingData.WBTC, // 955 USD
                USDT: fundingData.USDT // 300 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                if (token === "MATIC") {
                    // supply MATIC as collateral
                    const wrappedTokenGateway = IWrappedTokenGatewayV3__factory.connect(
                        aaveContractAddresses.wrappedTokenGateway,
                        user
                    );
                    await wrappedTokenGateway.depositETH(aaveV3Pool.address, user.address, referralCode, {
                        value: supplyAmounts.MATIC
                    });
                } else {
                    await tokenContracts[token].approve(aaveV3Pool.address, amount);
                    await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
                }
            }

            // total borrow amount equivalent to 435 USD
            const borrowAmounts = {
                USDCe: parseUnits("100", tokenDecimals.USDCe), // ~100 USD
                DAI: parseUnits("70", tokenDecimals.DAI), // ~70 USD
                LINK: parseUnits("15", tokenDecimals.LINK) // ~265 USD
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                await aaveV3Pool.borrow(tokenAddresses[token], amount, interestRateMode, referralCode, user.address);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                if (symbol === "MATIC") {
                    aTokenContracts["WMATIC"].approve(migratorV2.address, MaxUint256);
                } else {
                    await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
                }
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralsAave: {
                    MATIC: await aTokenContracts.WMATIC.balanceOf(user.address),
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address),
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address),
                    LINK: await debtTokenContracts.LINK.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC),
                    WMATIC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WMATIC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.USDCe,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountInMaximum: 1n
                        }
                    },
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.DAI,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.DAI, 20),
                                FEE_100,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountInMaximum: parseUnits("70", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100)
                        }
                    },
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.LINK,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.LINK, 20),
                                FEE_3000,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountInMaximum: parseUnits("265", tokenDecimals.USDCe)
                                .mul(SLIPPAGE_BUFFER_PERCENT)
                                .div(100)
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WMATIC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WMATIC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    },
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WBTC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    },
                    {
                        aToken: aaveContractAddresses.aToken.USDT,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.USDT, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.WMATIC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("435", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralsAave: {
                    MATIC: await aTokenContracts.WMATIC.balanceOf(user.address),
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address),
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address),
                    LINK: await debtTokenContracts.LINK.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC),
                    WMATIC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WMATIC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // all borrows should be closed
            expect(userBalancesAfter.borrowAave.DAI).to.be.equal(Zero);
            expect(userBalancesAfter.borrowAave.USDCe).to.be.equal(Zero);
            expect(userBalancesAfter.borrowAave.LINK).to.be.equal(Zero);
            //all collaterals should be migrated
            expect(userBalancesAfter.collateralsAave.WBTC).to.be.equal(Zero);
            expect(userBalancesAfter.collateralsAave.USDT).to.be.equal(Zero);
            expect(userBalancesAfter.collateralsAave.MATIC).to.be.equal(Zero);
            // all collaterals from Aave should be migrated to Comet as USDCe
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.equal(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.WMATIC).to.be.equal(userBalancesBefore.collateralsComet.WMATIC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.above(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);

        it("Scn.#2: partial collateral migration (by asset types)| three collateral and three borrow tokens | only swaps (coll. & borrow pos.)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WMATIC: parseEther("0.05"), // 130 USD
                WBTC: parseUnits("0.01", tokenDecimals.WBTC), // ~ 955 USD
                USDT: parseUnits("300", tokenDecimals.USDT)
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1385 USD
            const supplyAmounts = {
                WMATIC: fundingData.WMATIC, // 130 USD
                WBTC: fundingData.WBTC, // 955 USD
                USDT: fundingData.USDT // 300 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // total borrow amount equivalent to 625 USD
            const borrowAmounts = {
                USDCe: parseUnits("100", tokenDecimals.USDCe),
                DAI: parseUnits("70", tokenDecimals.DAI),
                LINK: parseUnits("30", tokenDecimals.LINK) // ~555 USD
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                await aaveV3Pool.borrow(tokenAddresses[token], amount, interestRateMode, referralCode, user.address);
            }

            // Approve migration
            await aTokenContracts.WBTC.approve(migratorV2.address, MaxUint256);

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralsAave: {
                    MATIC: await aTokenContracts.WMATIC.balanceOf(user.address),
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address),
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address),
                    LINK: await debtTokenContracts.LINK.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC),
                    WMATIC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WMATIC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.LINK,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.LINK, 20),
                                FEE_3000,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountInMaximum: parseUnits("555", tokenDecimals.USDCe)
                                .mul(SLIPPAGE_BUFFER_PERCENT)
                                .div(100)
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("555", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralsAave: {
                    MATIC: await aTokenContracts.WMATIC.balanceOf(user.address),
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address),
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address),
                    LINK: await debtTokenContracts.LINK.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC),
                    WMATIC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WMATIC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // all borrows should be closed
            expect(userBalancesAfter.borrowAave.DAI).to.be.not.equal(Zero);
            expect(userBalancesAfter.borrowAave.USDCe).to.be.not.equal(Zero);
            expect(userBalancesAfter.borrowAave.LINK).to.be.equal(Zero);
            //all collaterals should be migrated
            expect(userBalancesAfter.collateralsAave.WBTC).to.be.equal(Zero);
            expect(userBalancesAfter.collateralsAave.USDT).to.be.not.equal(Zero);
            expect(userBalancesAfter.collateralsAave.MATIC).to.be.not.equal(Zero);
            // all collaterals from Aave should be migrated to Comet as WBTC
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.above(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.equal(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);

        it("Scn.#3: migration of all collaterals | two collateral and two borrow tokens (incl. native token) | only swaps (coll. & borrow pos.)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool,
                wrappedTokenGateway
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC), // ~ 955 USD
                USDT: parseUnits("300", tokenDecimals.USDT)
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1385 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC, // 955 USD
                USDT: fundingData.USDT // 300 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // total borrow amount equivalent to 200 USD
            const borrowAmounts = {
                DAI: parseUnits("70", tokenDecimals.DAI),
                MATIC: parseEther("430") // ~130 USD
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                // borrow MATIC as collateral
                if (token === "MATIC") {
                    // approve delegation of MATIC to WrappedTokenGateway contract
                    await debtTokenContracts.WMATIC.approveDelegation(wrappedTokenGateway.address, MaxUint256);
                    await wrappedTokenGateway.borrowETH(aaveV3Pool.address, amount, referralCode);
                } else {
                    await aaveV3Pool.borrow(
                        tokenAddresses[token],
                        amount,
                        interestRateMode,
                        referralCode,
                        user.address
                    );
                }
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                borrowAave: {
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address),
                    MATIC: await debtTokenContracts.WMATIC.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.DAI,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.DAI, 20),
                                FEE_100,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountInMaximum: parseUnits("70", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100)
                        }
                    },
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.WMATIC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WMATIC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountInMaximum: parseUnits("130", tokenDecimals.USDCe)
                                .mul(SLIPPAGE_BUFFER_PERCENT)
                                .div(100)
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WBTC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    },
                    {
                        aToken: aaveContractAddresses.aToken.USDT,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.USDT, 20),
                                FEE_3000,
                                ethers.utils.hexZeroPad(tokenAddresses.WMATIC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("200", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                borrowAave: {
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address),
                    MATIC: await debtTokenContracts.WMATIC.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // all borrows should be closed
            expect(userBalancesAfter.borrowAave.DAI).to.be.equal(Zero);
            expect(userBalancesAfter.borrowAave.MATIC).to.be.equal(Zero);
            //all collaterals should be migrated
            expect(userBalancesAfter.collateralsAave.WBTC).to.be.equal(Zero);
            expect(userBalancesAfter.collateralsAave.USDT).to.be.equal(Zero);
            // all collaterals from Aave should be migrated to Comet as USDCe
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.equal(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.above(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);

        it("Scn.#4: migration of all collaterals | one collateral and one borrow tokens | without swaps", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC) // ~ 955 USD
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1055 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC // 955 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // total borrow amount equivalent to 250 USD
            const borrowAmounts = {
                USDCe: parseUnits("250", tokenDecimals.USDCe)
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                await aaveV3Pool.borrow(tokenAddresses[token], amount, interestRateMode, referralCode, user.address);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.USDCe,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountInMaximum: 1n
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("250", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // borrow should be closed
            expect(userBalancesAfter.borrowAave.USDCe).to.be.equal(Zero);
            // collateral should be migrated
            expect(userBalancesAfter.collateralAave.WBTC).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as WBTC
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.equal(userBalancesBefore.collateralsComet.USDCe);
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.above(userBalancesBefore.collateralsComet.WBTC);
        }).timeout(0);

        it("Scn.#5: migration of all collaterals | one collateral and one borrow tokens | only swaps (borrow pos.)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC) // ~ 955 USD
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1055 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC // 955 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // total borrow amount equivalent to 150 USD
            const borrowAmounts = {
                DAI: parseUnits("100", tokenDecimals.DAI)
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                await aaveV3Pool.borrow(tokenAddresses[token], amount, interestRateMode, referralCode, user.address);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.DAI,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.DAI, 20),
                                FEE_100,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountInMaximum: parseUnits("130", tokenDecimals.USDCe)
                                .mul(SLIPPAGE_BUFFER_PERCENT)
                                .div(100)
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("130", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // borrow should be closed
            expect(userBalancesAfter.borrowAave.DAI).to.be.equal(Zero);
            // collateral should be migrated
            expect(userBalancesAfter.collateralAave.WBTC).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as WBTC
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.equal(userBalancesBefore.collateralsComet.USDCe);
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.above(userBalancesBefore.collateralsComet.WBTC);
        }).timeout(0);

        it("Scn.#6: migration of all collaterals | one collateral and two borrow tokens | only swaps (borrow pos.)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC) // ~ 955 USD
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1055 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC // 955 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // total borrow amount equivalent to 115 USD
            const borrowAmounts = {
                DAI: parseUnits("70", tokenDecimals.DAI),
                USDCe: parseUnits("45", tokenDecimals.USDCe)
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                await aaveV3Pool.borrow(tokenAddresses[token], amount, interestRateMode, referralCode, user.address);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address),
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.DAI,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.DAI, 20),
                                FEE_100,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountInMaximum: parseUnits("70", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100)
                        }
                    },
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.USDCe,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountInMaximum: 1n
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("130", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address),
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // borrow should be closed
            expect(userBalancesAfter.borrowAave.DAI).to.be.equal(Zero);
            expect(userBalancesAfter.borrowAave.USDCe).to.be.equal(Zero);
            // collateral should be migrated
            expect(userBalancesAfter.collateralAave.WBTC).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as WBTC
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.equal(userBalancesBefore.collateralsComet.USDCe);
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.above(userBalancesBefore.collateralsComet.WBTC);
        }).timeout(0);

        it("Scn.#7: migration of all collaterals | one collateral and one borrow tokens | only swaps (coll. & barrow pos.)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC) // ~ 955 USD
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1055 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC // 955 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // total borrow amount equivalent to 115 USD
            const borrowAmounts = {
                DAI: parseUnits("100", tokenDecimals.DAI)
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                await aaveV3Pool.borrow(tokenAddresses[token], amount, interestRateMode, referralCode, user.address);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.DAI,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.DAI, 20),
                                FEE_100,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountInMaximum: parseUnits("100", tokenDecimals.USDCe)
                                .mul(SLIPPAGE_BUFFER_PERCENT)
                                .div(100)
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WBTC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("100", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    DAI: await debtTokenContracts.DAI.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // borrow should be closed
            expect(userBalancesAfter.borrowAave.DAI).to.be.equal(Zero);
            // collateral should be migrated
            expect(userBalancesAfter.collateralAave.WBTC).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as USDCe
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.equal(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.above(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);

        it("Scn.#8: migration of all collaterals | one collateral and one borrow tokens | only swaps (collateral pos.)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC) // ~ 955 USD
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 955 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC // 955 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // total borrow amount equivalent to 115 USD
            const borrowAmounts = {
                USDCe: parseUnits("100", tokenDecimals.USDCe)
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                await aaveV3Pool.borrow(tokenAddresses[token], amount, interestRateMode, referralCode, user.address);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.USDCe,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountInMaximum: 1n
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WBTC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("100", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // borrow should be closed
            expect(userBalancesAfter.borrowAave.USDCe).to.be.equal(Zero);
            // collateral should be migrated
            expect(userBalancesAfter.collateralAave.WBTC).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as USDCe
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.equal(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.above(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);

        it("Scn.#9: migration of all collaterals | tow collateral and one borrow tokens | only swaps (collateral pos.)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                debtTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC), // ~ 955 USD
                USDT: parseUnits("100", tokenDecimals.USDT)
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1055 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC, // 955 USD
                USDT: fundingData.USDT // 100 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // total borrow amount equivalent to 115 USD
            const borrowAmounts = {
                USDCe: parseUnits("100", tokenDecimals.USDCe)
            };

            for (const [token, amount] of Object.entries(borrowAmounts)) {
                await aaveV3Pool.borrow(tokenAddresses[token], amount, interestRateMode, referralCode, user.address);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [
                    {
                        debtToken: aaveContractAddresses.variableDebtToken.USDCe,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountInMaximum: 1n
                        }
                    }
                ],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WBTC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    },
                    {
                        aToken: aaveContractAddresses.aToken.USDT,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.USDT, 20),
                                FEE_3000,
                                ethers.utils.hexZeroPad(tokenAddresses.WMATIC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = parseUnits("100", tokenDecimals.USDCe).mul(SLIPPAGE_BUFFER_PERCENT).div(100);

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, flashAmount, anyValue);

            const userBalancesAfter = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                borrowAave: {
                    USDCe: await debtTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // borrow should be closed
            expect(userBalancesAfter.borrowAave.USDCe).to.be.equal(Zero);
            // collateral should be migrated
            expect(userBalancesAfter.collateralsAave.WBTC).to.be.equal(Zero);
            expect(userBalancesAfter.collateralsAave.USDT).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as USDCe
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.equal(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.above(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);

        it("Scn.#10: migration of all collaterals | two collateral without borrow tokens | without swaps", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC), // ~ 955 USD
                USDCe: parseUnits("100", tokenDecimals.USDCe)
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const referralCode = 0;

            // total supply amount equivalent to 1055 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC, // 955 USD
                USDCe: fundingData.USDCe // 100 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDCe: await aTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountOutMinimum: 1n
                        }
                    },
                    {
                        aToken: aaveContractAddresses.aToken.USDCe,
                        amount: MaxUint256,
                        swapParams: {
                            path: "0x",
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = Zero;

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, Zero, Zero);

            const userBalancesAfter = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDCe: await aTokenContracts.USDCe.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // collateral should be migrated
            expect(userBalancesAfter.collateralsAave.WBTC).to.be.equal(Zero);
            expect(userBalancesAfter.collateralsAave.USDCe).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as USDCe
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.above(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.above(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);

        it("Scn.#11: migration of all collaterals | two collateral without borrow tokens | only swaps (single-hop route)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC), // ~ 955 USD
                USDT: parseUnits("100", tokenDecimals.USDT)
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const interestRateMode = 2; // variable
            const referralCode = 0;

            // total supply amount equivalent to 1055 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC, // 955 USD
                USDT: fundingData.USDT // 100 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WBTC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    },
                    {
                        aToken: aaveContractAddresses.aToken.USDT,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.USDT, 20),
                                FEE_3000,
                                ethers.utils.hexZeroPad(tokenAddresses.WMATIC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = Zero;

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, Zero, Zero);

            const userBalancesAfter = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    USDT: await aTokenContracts.USDT.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // collateral should be migrated
            expect(userBalancesAfter.collateralsAave.WBTC).to.be.equal(Zero);
            expect(userBalancesAfter.collateralsAave.USDT).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as USDCe
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.equal(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.above(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);

        it("Scn.#12: migration of all collaterals | two collateral without borrow tokens | only swaps (multi-hop route)", async function () {
            const {
                user,
                treasuryAddresses,
                tokenAddresses,
                tokenContracts,
                tokenDecimals,
                aaveContractAddresses,
                aTokenContracts,
                compoundContractAddresses,
                AaveV3UsdsAdapter,
                migratorV2,
                aaveV3Pool
            } = await loadFixture(setupEnv);

            // simulation of the vault contract work
            const fundingData = {
                WBTC: parseUnits("0.01", tokenDecimals.WBTC), // ~ 955 USD
                DAI: parseUnits("3500", tokenDecimals.DAI)
            };
            // --- start
            for (const [token, amount] of Object.entries(fundingData)) {
                const tokenContract = tokenContracts[token];
                const treasuryAddress = treasuryAddresses[token];
                expect(await tokenContract.balanceOf(treasuryAddress)).to.be.above(amount);

                await setBalance(treasuryAddress, parseEther("1000"));
                await impersonateAccount(treasuryAddress);
                const treasurySigner = await ethers.getSigner(treasuryAddress);

                await tokenContract.connect(treasurySigner).transfer(user.address, amount);
                await stopImpersonatingAccount(treasuryAddress);
            }
            // --- end

            // setup the collateral and borrow positions in AaveV3
            const referralCode = 0;

            // total supply amount equivalent to 4455 USD
            const supplyAmounts = {
                WBTC: fundingData.WBTC, // 955 USD
                DAI: fundingData.DAI // 3500 USD
            };

            for (const [token, amount] of Object.entries(supplyAmounts)) {
                await tokenContracts[token].approve(aaveV3Pool.address, amount);
                await aaveV3Pool.supply(tokenAddresses[token], amount, user.address, referralCode);
            }

            // Approve migration
            for (const [symbol] of Object.entries(supplyAmounts)) {
                await aTokenContracts[symbol].approve(migratorV2.address, MaxUint256);
            }

            // set allowance for migrator to spend cUSDCev3
            const cUSDCv3Contract = IComet__factory.connect(compoundContractAddresses.markets.cUSDCev3, user);

            await cUSDCv3Contract.allow(migratorV2.address, true);
            expect(await cUSDCv3Contract.isAllowed(user.address, migratorV2.address)).to.be.true;

            const userBalancesBefore = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    DAI: await aTokenContracts.DAI.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesBefore:", userBalancesBefore);

            const deadline = await ethers.provider.getBlock("latest").then((block) => block.timestamp + 1000);
            const position = {
                borrows: [],
                collaterals: [
                    {
                        aToken: aaveContractAddresses.aToken.WBTC,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.WBTC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    },
                    {
                        aToken: aaveContractAddresses.aToken.DAI,
                        amount: MaxUint256,
                        swapParams: {
                            path: ethers.utils.concat([
                                ethers.utils.hexZeroPad(tokenAddresses.DAI, 20),
                                FEE_100,
                                ethers.utils.hexZeroPad(tokenAddresses.USDT, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.WMATIC, 20),
                                FEE_500,
                                ethers.utils.hexZeroPad(tokenAddresses.USDCe, 20)
                            ]),
                            deadline,
                            amountOutMinimum: 1n
                        }
                    }
                ]
            };

            // Encode the data
            const migrationData = ethers.utils.defaultAbiCoder.encode(
                ["tuple(" + POSITION_ABI.join(",") + ")"],
                [[position.borrows, position.collaterals]]
            );

            const flashAmount = Zero;

            await expect(
                migratorV2
                    .connect(user)
                    .migrate(
                        AaveV3UsdsAdapter.address,
                        compoundContractAddresses.markets.cUSDCev3,
                        migrationData,
                        flashAmount
                    )
            )
                .to.emit(migratorV2, "MigrationExecuted")
                .withArgs(AaveV3UsdsAdapter.address, user.address, cUSDCv3Contract.address, Zero, Zero);

            const userBalancesAfter = {
                collateralsAave: {
                    WBTC: await aTokenContracts.WBTC.balanceOf(user.address),
                    DAI: await aTokenContracts.DAI.balanceOf(user.address)
                },
                collateralsComet: {
                    USDCe: await cUSDCv3Contract.balanceOf(user.address),
                    WBTC: await cUSDCv3Contract.collateralBalanceOf(user.address, tokenAddresses.WBTC)
                }
            };

            logger("userBalancesAfter:", userBalancesAfter);

            // collateral should be migrated
            expect(userBalancesAfter.collateralsAave.WBTC).to.be.equal(Zero);
            expect(userBalancesAfter.collateralsAave.DAI).to.be.equal(Zero);
            // collaterals from Aave should be migrated to Comet as USDCe
            expect(userBalancesAfter.collateralsComet.WBTC).to.be.equal(userBalancesBefore.collateralsComet.WBTC);
            expect(userBalancesAfter.collateralsComet.USDCe).to.be.above(userBalancesBefore.collateralsComet.USDCe);
        }).timeout(0);
    });
});
